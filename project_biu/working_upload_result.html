<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Computation Graph Visualization</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .graph-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .graph-header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .graph-title {
            color: #333;
            font-size: 28px;
            font-weight: 600;
            margin: 0 0 10px 0;
        }
        
        .graph-subtitle {
            color: #666;
            font-size: 16px;
            margin: 0;
        }
        
        .graph-canvas {
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%),
                        linear-gradient(-45deg, #f8f9fa 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #f8f9fa 75%),
                        linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            width: 100%;
            height: 600px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .graph-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .graph-node:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }
        
        .node-topic {
            fill: #4ECDC4;
            stroke: #3bb5ad;
            stroke-width: 2;
        }
        
        .node-agent {
            fill: #FF6B6B;
            stroke: #e55353;
            stroke-width: 2;
        }
        
        .node-input {
            fill: #45B7D1;
            stroke: #3498db;
            stroke-width: 2;
        }
        
        .node-output {
            fill: #96CEB4;
            stroke: #7fb069;
            stroke-width: 2;
        }
        
        .node-operator {
            fill: #FFEAA7;
            stroke: #fdcb6e;
            stroke-width: 2;
        }
        
        .node-intermediate {
            fill: #DDA0DD;
            stroke: #ba68c8;
            stroke-width: 2;
        }
        
        .node-text {
            fill: #333;
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .graph-edge {
            stroke: #666;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        
        .graph-edge:hover {
            stroke: #007bff;
            stroke-width: 3;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .legend {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .legend-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }
        
        .info-panel {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }
        
        .info-panel.show {
            display: block;
        }
        
        .node-details {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="graph-container">
        <div class="graph-header">
            <h1 class="graph-title">üîó Computation Graph Visualization</h1>
            <p class="graph-subtitle">Dynamic graph generated from server-side configuration</p>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="centerGraph()">üéØ Center Graph</button>
            <button class="btn" onclick="zoomIn()">üîç Zoom In</button>
            <button class="btn" onclick="zoomOut()">üîç Zoom Out</button>
            <button class="btn" onclick="toggleAnimation()">‚ö° Toggle Animation</button>
            <button class="btn" onclick="exportGraph()">üíæ Export</button>
        </div>
        
        <div class="graph-canvas" id="graphCanvas">
            <svg class="graph-svg" id="graphSvg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                    </marker>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                        <feMerge> 
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            </svg>
        </div>
        
        <div class="legend">
            <div class="legend-title">üìã Node Types</div>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color node-topic"></div>
                    <span>Topics (Communication Channels)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-agent"></div>
                    <span>Agents (Processing Units)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-input"></div>
                    <span>Input Variables</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-output"></div>
                    <span>Output Results</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-operator"></div>
                    <span>Operators (+, -, √ó, √∑)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-intermediate"></div>
                    <span>Intermediate Values</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="graph-statistics">
  <h3>üìä Graph Statistics</h3>
  <div class="stats-grid">
    <div class="stat-item">
      <div class="stat-value">9</div>
      <div class="stat-label">Total Nodes</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">5</div>
      <div class="stat-label">Total Edges</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" style="color: #28a745">No</div>
      <div class="stat-label">Has Cycles</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">7</div>
      <div class="stat-label">Active Topics</div>
    </div>
  </div>
</div>

    
    <div class="info-panel" id="infoPanel">
        <h3>üîç Node Information</h3>
        <div id="nodeDetails" class="node-details">
            Click on a node to see detailed information.
        </div>
    </div>
    
    <script>
// Dynamically generated graph data
const graphData = {
  nodes: [
    { id: 0, label: 'AIncAgent', type: 'agent' },
    { id: 1, label: 'APlusAgent', type: 'agent' },
    { id: 2, label: 'Tsum_output', type: 'topic' },
    { id: 3, label: 'Ta', type: 'topic' },
    { id: 4, label: 'Tb', type: 'topic' },
    { id: 5, label: 'Tinput_a', type: 'topic' },
    { id: 6, label: 'Tfinal_result', type: 'topic' },
    { id: 7, label: 'Tinput_b', type: 'topic' },
    { id: 8, label: 'Tsum', type: 'topic' }
  ],
  edges: [
    { from: 0, to: 6 },
    { from: 1, to: 2 },
    { from: 2, to: 0 },
    { from: 5, to: 1 },
    { from: 7, to: 1 }
  ]
};
const topicData = [
  { name: 'sum_output', subscribers: 1, publishers: 1, lastMessage: '' },
  { name: 'a', subscribers: 0, publishers: 0, lastMessage: '' },
  { name: 'b', subscribers: 0, publishers: 0, lastMessage: '' },
  { name: 'input_a', subscribers: 1, publishers: 0, lastMessage: '' },
  { name: 'final_result', subscribers: 0, publishers: 1, lastMessage: '' },
  { name: 'input_b', subscribers: 1, publishers: 0, lastMessage: '' },
  { name: 'sum', subscribers: 0, publishers: 0, lastMessage: '' },
];
// Initialize graph visualization
if (typeof initializeGraphVisualization === 'function') {
  initializeGraphVisualization(graphData, topicData);
}
</script>
    
    <script>
        // Global variables for graph visualization
        let currentZoom = 1;
        let animationEnabled = true;
        let selectedNode = null;
        
        // Main function to initialize graph visualization
        function initializeGraphVisualization(graphData, topicData) {
            console.log('Initializing graph with data:', graphData);
            
            const svg = document.getElementById('graphSvg');
            const canvas = document.getElementById('graphCanvas');
            
            // Clear existing content
            while (svg.children.length > 1) {
                svg.removeChild(svg.lastChild);
            }
            
            if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
                drawEmptyState(svg);
                return;
            }
            
            // Calculate layout
            const layout = calculateLayout(graphData.nodes, graphData.edges);
            
            // Draw edges first (so they appear behind nodes)
            drawEdges(svg, graphData.edges, layout);
            
            // Draw nodes
            drawNodes(svg, graphData.nodes, layout);
            
            // Add interactivity
            addInteractivity(svg, graphData, topicData);
            
            // Update info panel with summary
            updateSummaryInfo(graphData, topicData);
        }
        
        function calculateLayout(nodes, edges) {
            const layout = {};
            const canvasRect = document.getElementById('graphCanvas').getBoundingClientRect();
            const width = canvasRect.width - 100; // Padding
            const height = canvasRect.height - 100;
            
            // Simple force-directed layout simulation
            nodes.forEach((node, index) => {
                const angle = (2 * Math.PI * index) / nodes.length;
                const radius = Math.min(width, height) / 3;
                
                layout[node.id] = {
                    x: width / 2 + radius * Math.cos(angle),
                    y: height / 2 + radius * Math.sin(angle),
                    node: node
                };
            });
            
            // Simple physics simulation to spread nodes
            for (let iteration = 0; iteration < 50; iteration++) {
                const forces = {};
                
                // Initialize forces
                nodes.forEach(node => {
                    forces[node.id] = { x: 0, y: 0 };
                });
                
                // Repulsion between all nodes
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const node1 = nodes[i];
                        const node2 = nodes[j];
                        const pos1 = layout[node1.id];
                        const pos2 = layout[node2.id];
                        
                        const dx = pos1.x - pos2.x;
                        const dy = pos1.y - pos2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        const force = 1000 / (distance * distance);
                        forces[node1.id].x += force * dx / distance;
                        forces[node1.id].y += force * dy / distance;
                        forces[node2.id].x -= force * dx / distance;
                        forces[node2.id].y -= force * dy / distance;
                    }
                }
                
                // Attraction for connected nodes
                edges.forEach(edge => {
                    const pos1 = layout[edge.from];
                    const pos2 = layout[edge.to];
                    
                    if (pos1 && pos2) {
                        const dx = pos2.x - pos1.x;
                        const dy = pos2.y - pos1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        const force = distance * 0.01;
                        forces[edge.from].x += force * dx / distance;
                        forces[edge.from].y += force * dy / distance;
                        forces[edge.to].x -= force * dx / distance;
                        forces[edge.to].y -= force * dy / distance;
                    }
                });
                
                // Apply forces
                nodes.forEach(node => {
                    const pos = layout[node.id];
                    pos.x += forces[node.id].x * 0.1;
                    pos.y += forces[node.id].y * 0.1;
                    
                    // Keep within bounds
                    pos.x = Math.max(50, Math.min(width - 50, pos.x));
                    pos.y = Math.max(50, Math.min(height - 50, pos.y));
                });
            }
            
            return layout;
        }
        
        function drawNodes(svg, nodes, layout) {
            nodes.forEach(node => {
                const pos = layout[node.id];
                if (!pos) return;
                
                // Create group for node
                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                nodeGroup.setAttribute('class', 'graph-node');
                nodeGroup.setAttribute('data-node-id', node.id);
                nodeGroup.setAttribute('data-node-type', node.type);
                
                // Create node shape (rectangle with rounded corners)
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textLength = node.label.length * 8 + 20;
                const nodeWidth = Math.max(60, textLength);
                const nodeHeight = 30;
                
                rect.setAttribute('x', pos.x - nodeWidth / 2);
                rect.setAttribute('y', pos.y - nodeHeight / 2);
                rect.setAttribute('width', nodeWidth);
                rect.setAttribute('height', nodeHeight);
                rect.setAttribute('rx', 8);
                rect.setAttribute('ry', 8);
                rect.setAttribute('class', `node-${node.type}`);
                
                // Create text label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y);
                text.setAttribute('class', 'node-text');
                text.textContent = node.label;
                
                nodeGroup.appendChild(rect);
                nodeGroup.appendChild(text);
                svg.appendChild(nodeGroup);
                
                // Store position in layout for edge drawing
                layout[node.id].width = nodeWidth;
                layout[node.id].height = nodeHeight;
            });
        }
        
        function drawEdges(svg, edges, layout) {
            edges.forEach(edge => {
                const fromPos = layout[edge.from];
                const toPos = layout[edge.to];
                
                if (!fromPos || !toPos) return;
                
                // Calculate edge path
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromPos.x);
                line.setAttribute('y1', fromPos.y);
                line.setAttribute('x2', toPos.x);
                line.setAttribute('y2', toPos.y);
                line.setAttribute('class', 'graph-edge');
                
                svg.appendChild(line);
            });
        }
        
        function addInteractivity(svg, graphData, topicData) {
            // Add click handlers to nodes
            svg.addEventListener('click', (event) => {
                const nodeElement = event.target.closest('.graph-node');
                if (nodeElement) {
                    const nodeId = parseInt(nodeElement.getAttribute('data-node-id'));
                    const node = graphData.nodes.find(n => n.id === nodeId);
                    
                    if (node) {
                        selectNode(node, topicData);
                    }
                }
            });
        }
        
        function selectNode(node, topicData) {
            selectedNode = node;
            
            // Update info panel
            const infoPanel = document.getElementById('infoPanel');
            const nodeDetails = document.getElementById('nodeDetails');
            
            let detailsHTML = `
                <h4>üè∑Ô∏è ${node.label}</h4>
                <p><strong>Type:</strong> ${node.type.charAt(0).toUpperCase() + node.type.slice(1)}</p>
                <p><strong>ID:</strong> ${node.id}</p>
            `;
            
            // Add topic-specific information if available
            if (node.type === 'topic' && topicData) {
                const topicInfo = topicData.find(t => t.name === node.label || t.name === node.label.substring(1));
                if (topicInfo) {
                    detailsHTML += `
                        <p><strong>Subscribers:</strong> ${topicInfo.subscribers}</p>
                        <p><strong>Publishers:</strong> ${topicInfo.publishers}</p>
                        <p><strong>Last Message:</strong> ${topicInfo.lastMessage || 'None'}</p>
                    `;
                }
            }
            
            nodeDetails.innerHTML = detailsHTML;
            infoPanel.classList.add('show');
        }
        
        function updateSummaryInfo(graphData, topicData) {
            console.log('Graph loaded successfully!');
            console.log(`Nodes: ${graphData.nodes.length}, Edges: ${graphData.edges.length}`);
            console.log(`Topics: ${topicData.length}`);
        }
        
        function drawEmptyState(svg) {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', '50%');
            text.setAttribute('y', '50%');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'central');
            text.setAttribute('font-size', '18');
            text.setAttribute('fill', '#666');
            text.textContent = 'No graph data available';
            svg.appendChild(text);
        }
        
        // Control functions
        function centerGraph() {
            currentZoom = 1;
            // Re-render graph with original scale
            if (window.graphData) {
                initializeGraphVisualization(window.graphData, window.topicData);
            }
        }
        
        function zoomIn() {
            currentZoom *= 1.2;
            applyZoom();
        }
        
        function zoomOut() {
            currentZoom /= 1.2;
            applyZoom();
        }
        
        function applyZoom() {
            const svg = document.getElementById('graphSvg');
            svg.style.transform = `scale(${currentZoom})`;
        }
        
        function toggleAnimation() {
            animationEnabled = !animationEnabled;
            const nodes = document.querySelectorAll('.graph-node');
            nodes.forEach(node => {
                if (animationEnabled) {
                    node.style.transition = 'all 0.3s ease';
                } else {
                    node.style.transition = 'none';
                }
            });
        }
        
        function exportGraph() {
            // Simple export functionality
            const svg = document.getElementById('graphSvg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svg);
            
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'computation_graph.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Store data globally for control functions
        window.graphData = null;
        window.topicData = null;
        
        // Initialize empty state if no data is provided
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                if (!window.graphData) {
                    drawEmptyState(document.getElementById('graphSvg'));
                }
            }, 100);
        });
    </script>
</body>
</html>
